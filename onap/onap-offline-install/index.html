<!doctype html>
<html lang="en-us">
  <head>
    <title>ONAP 离线安装 // JiangX</title>
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.57.2" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="Jiang Xing" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="https://vincent-wuhan.github.io/css/main.min.59023e5fd38d6ecb0e1dfbb295077c3c67e00e3b9eb3feaf34b5a5e6b332897a.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="ONAP 离线安装"/>
<meta name="twitter:description" content="环境准备  硬件环境 软件条件  安装目录结构 安装前提 docker安装 文件服务器  nginx配置 文件服务器启动脚本  安装说明 docker镜像仓库  镜像仓库启动脚本 启动仓库  rancher安装 下载rancher.sh  安装rancher  k8s安装  下载k8s-node.sh 安装k8s  rancher&amp;Kubernetes API  kubernetes template获取 rancher env添加 rancher host添加 kubectl token获取  helm私有仓库http服务器搭建 Chart仓库管理基础环境安装  helm安装helm-push插件 kubeapps要求  安装脚本 tiller需要获取超级权限 token获取   主动重启  重启前删除所有部署 启动后重新安装部署  Q&amp;A TODO  环境准备 19年应公司需求做了一个ONAP离线安装的工具, 这里不细说代码,只说明实现框架
硬件环境    RAM HD vCores Ports     128G 160G 32 0."/>

    <meta property="og:title" content="ONAP 离线安装" />
<meta property="og:description" content="环境准备  硬件环境 软件条件  安装目录结构 安装前提 docker安装 文件服务器  nginx配置 文件服务器启动脚本  安装说明 docker镜像仓库  镜像仓库启动脚本 启动仓库  rancher安装 下载rancher.sh  安装rancher  k8s安装  下载k8s-node.sh 安装k8s  rancher&amp;Kubernetes API  kubernetes template获取 rancher env添加 rancher host添加 kubectl token获取  helm私有仓库http服务器搭建 Chart仓库管理基础环境安装  helm安装helm-push插件 kubeapps要求  安装脚本 tiller需要获取超级权限 token获取   主动重启  重启前删除所有部署 启动后重新安装部署  Q&amp;A TODO  环境准备 19年应公司需求做了一个ONAP离线安装的工具, 这里不细说代码,只说明实现框架
硬件环境    RAM HD vCores Ports     128G 160G 32 0." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://vincent-wuhan.github.io/onap/onap-offline-install/" />
<meta property="article:published_time" content="2020-03-01T14:08:22+08:00" />
<meta property="article:modified_time" content="2020-03-01T14:08:22+08:00" />


  </head>
  <body>
    <header class="app-header">
      <a href="https://vincent-wuhan.github.io"><img class="app-header-avatar" src="/avatar.jpg" alt="Jiang Xing" /></a>
      <h1>JiangX</h1>
      <p>Xing&#39;s personal website</p>
      <div class="app-header-social">
        
          <a target="_blank" href="https://github.com/vincent-wuhan/"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <title>github</title>
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg></a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">ONAP 离线安装</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Mar 1, 2020
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          4 min read
        </div></div>
    </header>
    <div class="post-content">
      

<!-- TOC -->

<ul>
<li><a href="#环境准备">环境准备</a>

<ul>
<li><a href="#硬件环境">硬件环境</a></li>
<li><a href="#软件条件">软件条件</a></li>
</ul></li>
<li><a href="#安装目录结构">安装目录结构</a></li>
<li><a href="#安装前提">安装前提</a></li>
<li><a href="#docker安装">docker安装</a></li>
<li><a href="#文件服务器">文件服务器</a>

<ul>
<li><a href="#nginx配置">nginx配置</a></li>
<li><a href="#文件服务器启动脚本">文件服务器启动脚本</a></li>
</ul></li>
<li><a href="#安装说明">安装说明</a></li>
<li><a href="#docker镜像仓库">docker镜像仓库</a>

<ul>
<li><a href="#镜像仓库启动脚本">镜像仓库启动脚本</a></li>
<li><a href="#启动仓库">启动仓库</a></li>
</ul></li>
<li><a href="#rancher安装">rancher安装</a></li>
<li><a href="#下载ranchersh">下载rancher.sh</a>

<ul>
<li><a href="#安装rancher">安装rancher</a></li>
</ul></li>
<li><a href="#k8s安装">k8s安装</a>

<ul>
<li><a href="#下载k8s-nodesh">下载k8s-node.sh</a></li>
<li><a href="#安装k8s">安装k8s</a></li>
</ul></li>
<li><a href="#rancherkubernetes-api">rancher&amp;Kubernetes API</a>

<ul>
<li><a href="#kubernetes-template获取">kubernetes template获取</a></li>
<li><a href="#rancher-env添加">rancher env添加</a></li>
<li><a href="#rancher-host添加">rancher host添加</a></li>
<li><a href="#kubectl-token获取">kubectl token获取</a></li>
</ul></li>
<li><a href="#helm私有仓库http服务器搭建">helm私有仓库http服务器搭建</a></li>
<li><a href="#chart仓库管理基础环境安装">Chart仓库管理基础环境安装</a>

<ul>
<li><a href="#helm安装helm-push插件">helm安装helm-push插件</a></li>
<li><a href="#kubeapps要求">kubeapps要求</a>

<ul>
<li><a href="#安装脚本">安装脚本</a></li>
<li><a href="#tiller需要获取超级权限">tiller需要获取超级权限</a></li>
<li><a href="#token获取">token获取</a></li>
</ul></li>
</ul></li>
<li><a href="#主动重启">主动重启</a>

<ul>
<li><a href="#重启前删除所有部署">重启前删除所有部署</a></li>
<li><a href="#启动后重新安装部署">启动后重新安装部署</a></li>
</ul></li>
<li><a href="#qa">Q&amp;A</a></li>
<li><a href="#todo">TODO</a></li>
</ul>

<!-- /TOC -->

<h2 id="环境准备">环境准备</h2>

<p>19年应公司需求做了一个ONAP离线安装的工具, 这里不细说代码,只说明实现框架</p>

<h3 id="硬件环境">硬件环境</h3>

<table>
<thead>
<tr>
<th align="left">RAM</th>
<th align="left">HD</th>
<th align="left">vCores</th>
<th align="left">Ports</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">128G</td>
<td align="left">160G</td>
<td align="left">32</td>
<td align="left">0.0.0.0/0</td>
</tr>

<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody>
</table>

<h3 id="软件条件">软件条件</h3>

<table>
<thead>
<tr>
<th align="left">Release</th>
<th align="left">Kubernetes</th>
<th align="left">Helm</th>
<th align="left">kubectl</th>
<th align="left">Docker</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">amsterdam</td>
<td align="left">1.7.x</td>
<td align="left">2.3.x</td>
<td align="left">1.7.x</td>
<td align="left">1.12.x</td>
</tr>

<tr>
<td align="left">beijing/master</td>
<td align="left">1.8.10</td>
<td align="left">2.8.2</td>
<td align="left">1.8.10</td>
<td align="left">17.03.x</td>
</tr>

<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody>
</table>

<h2 id="安装目录结构">安装目录结构</h2>

<pre><code class="language-tree">install
|
|___ env
|     |___ file.conf
|     |___ create_file_server.sh
|     |___ install_docker.sh
|     |___ create_docker_registry.sh
|     |___ repo
|     |     |___ helm chart packages
|     |___ dockers
|     |     |___ docker images cache
|     |___ data
|           |___ scripts
|           |       |___ rancher.sh
|           |       |___ k8s-node.sh
|           |       |___ helm.sh
|           |       |___ ...  
|           |___ softwares
|                   |___ libltdl7_2.4.6-0.1_amd64.deb
|                   |___ docker-ce_17.03.0~ce-0~ubuntu-xenial_amd64.deb
|                   |___ ...
|___ start.py
|___ readme.md

</code></pre>

<h2 id="安装前提">安装前提</h2>

<p>管理员权限运行安装</p>

<h2 id="docker安装">docker安装</h2>

<p>install_docker.sh</p>

<pre><code class="language-shell">#!/usr/bin/env bash
cd ./data/softwares
sudo dpkg -i libltdl7_2.4.6-0.1_amd64.deb
sudo dpkg -i docker-ce_17.03.0~ce-0~ubuntu-xenial_amd64.deb

echo -e  &quot;{\n\&quot;registry-mirrors\&quot;: [\n\&quot;https://registry.docker-cn.com\&quot;\n],\n\&quot;insecure-registries\&quot;: [\&quot;$DOCKER_SERVER\&quot;,\&quot;nexus3.onap.org:10001\&quot;,\&quot;nexus3.onap.org\&quot;]\n}&quot; &gt;&gt; /etc/docker/daemon.json

service docker restart
</code></pre>

<h2 id="文件服务器">文件服务器</h2>

<h3 id="nginx配置">nginx配置</h3>

<p>file.conf</p>

<pre><code class="language-conf">log_format  p_access.log  '$remote_addr - $remote_user [$time_local] &quot;$request&quot; '
             '$status $body_bytes_sent &quot;$http_referer&quot; '
             '&quot;$http_user_agent&quot; $http_x_forwarded_for';
server
    {
        listen       8000;  # 监听 8000 端口，按需求也可以配置一个前台服务器作子域名转发
        index index.html default.html; # 默认首页文件
        root  /var/www/file;   #文件服务器的根路径
        autoindex on;
        autoindex_exact_size off;
        autoindex_localtime on;
        charset utf-8;
                # 这里配置拒绝访问的目录或文件
        location ~ (repos)
        {
            deny all;
        }

                # 静态文件的过期时间，可以不需要此配置
        location ~ .*\.(gif|jpg|jpeg|png|bmp|swf)$
            {
                expires      30d;
            }
                # 静态文件的过期时间，可以不需要此配置
        location ~ .*\.(js|css)?$
            {
                expires      12h;
            }
                 # 这里很重要! 将日志转发到 /dev/stdout ，可以通过 docker logs -f  来查看容器日志
        access_log  /dev/stdout;
    }
</code></pre>

<h3 id="文件服务器启动脚本">文件服务器启动脚本</h3>

<p>create_file_server.sh</p>

<pre><code class="language-shell">#!/usr/bin/env bash

if [ ! -d './data' ]
then
    mkdir data
fi

# 重点解释这里吧
docker run -dit --name files0 \
--restart always \
-p 3002:8000 \
-v $PWD/file.conf:/etc/nginx/conf.d/file.conf \
-v $PWD/data:/var/www/file \
-w /var/www/file \
nginx

</code></pre>

<h2 id="安装说明">安装说明</h2>

<ol>
<li><p>任意一个地方建立独立目录</p>

<pre><code class="language-shell">mkdir documents
cd documents
</code></pre></li>

<li><p>拷贝file.conf和create_file_server.sh到目录中</p></li>

<li><p>执行create_file_server.sh</p>

<pre><code class="language-shell">./create_file_server.sh
</code></pre></li>
</ol>

<h2 id="docker镜像仓库">docker镜像仓库</h2>

<h3 id="镜像仓库启动脚本">镜像仓库启动脚本</h3>

<p>create_docker_registry.sh</p>

<p>在线安装</p>

<pre><code class="language-shell">#!/user/bin/env bash
 docker run -d \
 --restart=unless-stopped \
 --name registry \
 -e REGISTRY_HTTP_ADDR=0.0.0.0:5000 \
 -e REGISTRY_PROXY_REMOTEURL=https://nexus3.onap.org:10001 \
 -p 5000:5000 \
 registry:2
</code></pre>

<p>离线安装</p>

<pre><code class="language-shell">#!/usr/bin/env bash
 docker run -d \
 --restart=unless-stopped \
 --name registry \
 -e REGISTRY_HTTP_ADDR=0.0.0.0:5000 \
 -p 5000:5000 \
 registry:2
</code></pre>

<h3 id="启动-仓库">启动仓库</h3>

<pre><code class="language-shell">./create_docker_registry.sh
</code></pre>

<h2 id="rancher安装">rancher安装</h2>

<h2 id="下载rancher-sh">下载rancher.sh</h2>

<pre><code class="language-shell">export HTTP_SERVER=localhost:3002
curl -O http://$HTTP_SERVER/scripts/rancher.sh

</code></pre>

<h3 id="安装rancher">安装rancher</h3>

<pre><code class="language-shell">./rancher.sh
</code></pre>

<h2 id="k8s安装">k8s安装</h2>

<h3 id="下载k8s-node-sh">下载k8s-node.sh</h3>

<pre><code class="language-shell">export HTTP_SERVER=localhost:3002
curl -O http://$HTTP_SERVER/scripts/k8s-node.sh
</code></pre>

<h3 id="安装k8s">安装k8s</h3>

<pre><code class="language-shell">./k8s-node.sh
</code></pre>

<h2 id="rancher-kubernetes-api">rancher&amp;Kubernetes API</h2>

<h3 id="kubernetes-template获取">kubernetes template获取</h3>

<p>RESTful API
GET http://{rancher-server}:{rancher-port}/v2-beta/projecttemplates</p>

<p>Body中遍历data获得name为Kubernetes的id属性</p>

<pre><code class="language-json">    &quot;data&quot;: [
        {
            &quot;id&quot;: &quot;1pt1&quot;,
            &quot;type&quot;: &quot;projectTemplate&quot;,
            &quot;links&quot;: {
                &quot;self&quot;: &quot;http://10.190.49.74:8080/v2-beta/projecttemplates/1pt1&quot;,
                &quot;accounts&quot;: &quot;http://10.190.49.74:8080/v2-beta/projecttemplates/1pt1/accounts&quot;
            },
            &quot;actions&quot;: {
                &quot;remove&quot;: &quot;http://10.190.49.74:8080/v2-beta/projecttemplates/1pt1/?action=remove&quot;
            },
            &quot;baseType&quot;: &quot;projectTemplate&quot;,
            &quot;name&quot;: &quot;Kubernetes&quot;,
            &quot;state&quot;: &quot;active&quot;,
            &quot;accountId&quot;: null,
</code></pre>

<h3 id="rancher-env添加">rancher env添加</h3>

<p>RESTful API</p>

<p>POST http://{rancher-server}:{rancher-port}/v2-beta/projects</p>

<p>Body:</p>

<pre><code class="language-json">{
&quot;description&quot;: &quot;description context&quot;,
&quot;name&quot;: &quot;env name&quot;,
&quot;projectTemplateId&quot;: &quot;template id&quot;,
&quot;hostRemoveDelaySeconds&quot;: 60,
&quot;allowSystemRole&quot;: false,
&quot;members&quot;: [ ],
&quot;virtualMachine&quot;: true,
&quot;servicesPortRange&quot;: null,
&quot;projectLinks&quot;: []
}
</code></pre>

<h3 id="rancher-host添加">rancher host添加</h3>

<p>RESTful API
GET http://{rancher-server}:{rancher-port}/v2-beta/projects/{project-id}/registrationtokens?state=active&amp;limit=-1&amp;sort=name</p>

<p>Body中，data.command的加上 -e CATTLE_AGENT_IP=&ldquo;{K8s-node-ip}&rdquo;</p>

<p>举例：</p>

<pre><code class="language-shell">sudo docker run -e CATTLE_AGENT_IP=&quot;10.0.0.12&quot;  --rm --privileged -v /var/run/docker.sock:/var/run/docker.sock -v /var/lib/rancher:/var/lib/rancher rancher/agent:v1.2.9 http://10.190.49.74:8080/v1/scripts/BB74B483F2F4CD897835:1546214400000:VVdh7rQkkjDLZIkNpvtTa4cC3Y

</code></pre>

<p>在{K8s-node-ip}对应的节点上运行command安装host</p>

<h3 id="kubectl-token获取">kubectl token获取</h3>

<pre><code class="language-js">const NEW_CONFIG_TPL = `apiVersion: v1
kind: Config
clusters:
- cluster:
    api-version: v1%maybeInsecure%
    server: &quot;%baseUrl%/r/projects/%projectId%/kubernetes:6443&quot;
  name: &quot;%projectName%&quot;
contexts:
- context:
    cluster: &quot;%projectName%&quot;
    user: &quot;%projectName%&quot;
  name: &quot;%projectName%&quot;
current-context: &quot;%projectName%&quot;
users:
- name: &quot;%projectName%&quot;
  user:
    token: &quot;%token%&quot;`;
</code></pre>

<p>使用base64加密publicValue和secretValue获取token，以下是从kubenetes dashboard开源项目中截取的token生成的js代码片段</p>

<pre><code class="language-js"> let token = btoa('Basic ' + btoa(key.get('publicValue') + ':' + key.get('secretValue')));

        var config = tpl
          .replace(/%baseUrl%/g,     base)
          .replace(/%maybeInsecure%/g,(insecure ? '\n    insecure-skip-tls-verify: true' : ''))
          .replace(/%projectName%/g, this.get('projects.current.displayName'))
          .replace(/%projectId%/g,   this.get('projects.current.id'))
          .replace(/%publicValue%/g, key.get('publicValue'))
          .replace(/%secretValue%/g, key.get('secretValue'))
          .replace(/%token%/g, token);
</code></pre>

<p>改用python实现</p>

<p>id: 1c85
publicValue: B141C7D4EB8E21373C17
secretValue: AwYjBpcvsFsht24AYPNAyr4exjdbRmppagbno9Yo</p>

<pre><code class="language-python">import base64
base64.b64encode('Basic ' + base64.b64encode('B141C7D4EB8E21373C17' + ':' + 'AwYjBpcvsFsht24AYPNAyr4exjdbRmppagbno9Yo'))
</code></pre>

<p>输出</p>

<pre><code class="language-shell">QmFzaWMgUWpFME1VTTNSRFJGUWpoRk1qRXpOek5ETVRjNlFYZFpha0p3WTNaelJuTm9kREkwUVZsUVRrRjVjalJsZUdwa1lsSnRjSEJoWjJKdWJ6bFpidz09
</code></pre>

<h2 id="helm私有仓库http服务器搭建">helm私有仓库http服务器搭建</h2>

<p><a href="https://wiki.shileizcc.com/confluence/display/KUB/Kubernetes+Helm">https://wiki.shileizcc.com/confluence/display/KUB/Kubernetes+Helm</a></p>

<p>搜索: &ldquo;搭建私有 Repository&rdquo;</p>

<pre><code class="language-txt">搭建私有 Repository
自建 Chart 之后，自然需要搭建私有仓库。下面使用 Apache 来搭建一个简单的 Chart 私有仓库，并将刚才新建的 mymariadb Chart 保存到私有仓库中。相关文档：https://docs.helm.sh/developing_charts/#the-chart-repository-guide

Chart 仓库主要由前面提到的 Chart 压缩包和索引文件构成，通过 HTTP/HTTPS 对外提供服务。这里使用一个 Apache 应用来提供仓库服务。Apache 的设置如下。

Apache 使用 /var/web/repo 目录进行仓库的存储。
使用 http://127.0.0.1/repo 网址提供访问服务。
将前面生成的 mymariadb-0.1.1.tgz 文件复制到仓库的 /var/web/repo 目录中。

接下来使用 helm repo index /var/web/repo --url http://127.0.0.1/repo 命令，Helm 将自动根据目录中的内容创建索引。命令执行完成后，可以看到目录下多出来了一个 index.yaml 文件。

最后启动 Web Server。

为了能够使用这个私有仓库，需要将这个新的仓库地址加入到 Helm 配置中：

$ helm repo add localhost http://127.0.0.1/repo
再次运行 helm search mysql 命令，就会看到 Chart 列表中多出来的 localhost/mymariadb 项目了，也就是新仓库中的  Chart。

可以使用 install 命令进行安装。
</code></pre>

<h2 id="chart仓库管理基础环境安装">Chart仓库管理基础环境安装</h2>

<h3 id="helm安装helm-push插件">helm安装helm-push插件</h3>

<p>网络环境代理：
export http_proxy=&ldquo;<a href="http://10.190.51.201:7788&quot;">http://10.190.51.201:7788&quot;</a>  export https_proxy=&ldquo;<a href="http://10.190.51.201:7788&quot;">http://10.190.51.201:7788&quot;</a></p>

<p>export http_proxy=&ldquo;<a href="http://10.190.49.200:8118&quot;">http://10.190.49.200:8118&quot;</a>  export https_proxy=&ldquo;<a href="http://10.190.49.200:8118&quot;">http://10.190.49.200:8118&quot;</a></p>

<pre><code class="language-shell">helm plugin install https://github.com/chartmuseum/helm-push
</code></pre>

<p>增加harbor仓库</p>

<pre><code class="language-shell">helm repo add {REPONAME} {HABOR_REPO_URL}
例如：
helm repo add mano http://10.190.49.74/chartrepo/onap
</code></pre>

<p>push helm的tgz包到远程仓库</p>

<pre><code class="language-shell">helm push --username=admin --password=Harbor12345 kubeapps-123.tgz mano
</code></pre>

<p>在推送完毕后，远程仓库可以查看到已经更新，但是本地仓库需要执行helm update才会更新显示出来</p>

<p>helm安装包指定docker镜像仓库</p>

<pre><code class="language-shell">helm install mano/kubeapps --version 0.9.7 -n kubeapps --namespace kubeapps --set global.repository=1.1.1.11:10001
</code></pre>

<h3 id="kubeapps要求">kubeapps要求</h3>

<p>helm 2.9.1</p>

<h4 id="安装脚本">安装脚本</h4>

<p>tar -zxvf helm-v2.9.1-linux-amd64.tar.gz)
mv linux-amd64/helm /usr/local/bin/helm
helm init &ndash;upgrade</p>

<p>kubeapps 0.9.7版本</p>

<p>&ndash;version 0.9.7</p>

<h4 id="tiller需要获取超级权限">tiller需要获取超级权限</h4>

<pre><code class="language-shell">kubectl -n kube-system create sa tiller
kubectl create clusterrolebinding tiller --clusterrole cluster-admin --serviceaccount=kube-system:tiller
helm init --service-account tiller
</code></pre>

<p>helm install mano/kubeapps &ndash;version 0.9.7 -n kubeapps &ndash;namespace kubeapps &ndash;set global.repository=1.1.1.11:10001
kubectl create serviceaccount kubeapps-operator
kubectl create clusterrolebinding kubeapps-operator &ndash;clusterrole=cluster-admin &ndash;serviceaccount=default:kubeapps-operator</p>

<p>使用chart仓库安装
helm install mano/kubeapps &ndash;version 0.9.7 &ndash;name kubeapps &ndash;namespace kubeapps &ndash;set rbac.create=false,global.repository=1.1.1.15:10001</p>

<p>使用安装包安装
helm install ./kubeapps-0.9.7.tgz -n kubeapps &ndash;namespace kubeapps &ndash;set rbac.create=false,global.repository=1.1.1.11:10001</p>

<h4 id="token获取">token获取</h4>

<p>kubeapp登陆界面端口，根据kubernetes中服务kubeapps映射的nodeport进行访问，访问时，登陆界面需要token使用如下命令在kubectl界面获得token</p>

<pre><code class="language-shell">kubectl -n kube-system describe secret $(kubectl -n kube-system get secret | grep admin-user | awk '{print $1}')
</code></pre>

<h2 id="主动重启">主动重启</h2>

<h3 id="重启前删除所有部署">重启前删除所有部署</h3>

<pre><code class="language-shell">helm delete --purge $(helm list|grep &quot;dev&quot;|awk '{print $1}’)
</code></pre>

<h3 id="启动后重新安装部署">启动后重新安装部署</h3>

<p>在K8s节点根据需求重启部署</p>

<pre><code class="language-shell">启动fitmano：
python onap.py onap all
或
bash /root/onap.sh all &amp;

启动nfvo
python onap.py onap nfvo
或
bash /root/onap.sh nfvo &amp;

启动vnfm
python onap.py onap vnfm
或
bash /root/onap.sh vnfm &amp;
</code></pre>

<h2 id="q-a">Q&amp;A</h2>

<p>如何判断rancher和k8s都已经安装完毕？</p>

<p>如何判断Host已经添加完毕？</p>

<h2 id="todo">TODO</h2>

<p>IP 探测 &amp;&amp; 虚拟机安装
 一键部署自动化(IP创建后返回、环境探测)
 一键部署界</p>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
